<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript继承</title>
    <link href="/2023/02/22/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/02/22/JavaScript%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>由于JavaScript语言特性，它的继承类的继承方式是通过原型配合构造函数完成的，即使是ES6中出现的所谓的class和extends关键字，也仅仅是一种语法糖而已！</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="es5的继承"><a href="#es5的继承" class="headerlink" title="es5的继承"></a>es5的继承</h3><p>es5中属性的继续通过子类调用父类的构造函数（一般通过call的方式），方法的继承通过原型（子类的prototype指向父类的实例）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Feather</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 在原型上扩展方法。（作为构造函数时，属性一般作为每一个实例所特有的，方法作为所以实例所共有的，所以属性的初始化放在构造函数中，方法都放在原型上，因为原型对象上的方法会被所有实例所共享）</span><br><span class="hljs-title class_">Feather</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;大家好，我叫&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params">name, age, score</span>)&#123;<br>  <span class="hljs-title class_">Feather</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<span class="hljs-comment">//call的目的就是调用父类的构造函数，并使得父类中的this指向子类实例，从而对属性进行赋值（属性的继承）</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feather</span>();<span class="hljs-comment">//子类的原型指向父类的实例（一个构造函数的原型是可以直接指向一个对象的）</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Son</span>;<span class="hljs-comment">//这一步很关键</span><br><span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;在学习！&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feather</span>(<span class="hljs-string">&quot;老王&quot;</span>, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;小王&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">90</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br>f.<span class="hljs-title function_">sayHello</span>();<span class="hljs-comment">//sayHello本来是父类的原型方法，所以父类的实例自然可以直接使用</span><br>s.<span class="hljs-title function_">sayHello</span>();<span class="hljs-comment">//子类的原型上虽然没有sayHello方法，但它直接继承了父类的方法，所以子类的实例自然可以调用这个方法。</span><br>s.<span class="hljs-title function_">study</span>();<span class="hljs-comment">//子类独有的方法，其实例可以直接使用。</span><br></code></pre></td></tr></table></figure><center>    <img src="jc.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">显然子类的原型上没有sayHello方法，但子类的实例却能直接调用父类原型上的方法</div></center><h3 id="es6的继承"><a href="#es6的继承" class="headerlink" title="es6的继承"></a>es6的继承</h3><p>es6提出了class、extends关键字，写起来更加的方便简洁，更像传统面向对象语言（比如Java、C++、Python等）的语法，但这也仅仅是一种语法糖而已，并没有改变其基于原型的本质。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Feather</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;,我&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot;岁了。&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Feather</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, score</span>)&#123;<br>    <span class="hljs-variable language_">super</span>(name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>  &#125;<br>  <span class="hljs-title function_">study</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;在学习。&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feather</span>(<span class="hljs-string">&quot;老李&quot;</span>, <span class="hljs-number">40</span>);<br><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&quot;小李&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">93</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br>f.<span class="hljs-title function_">sayHello</span>();<span class="hljs-comment">//sayHello本来是父类的共有方法，所以父类的实例自然可以直接使用</span><br>s.<span class="hljs-title function_">sayHello</span>();<span class="hljs-comment">//子类虽然没有sayHello共有方法，但它直接继承了父类的方法，所以子类的实例自然可以调用这个方法。</span><br>s.<span class="hljs-title function_">study</span>();<span class="hljs-comment">//子类独有的方法，其实例可以直接使用。</span><br></code></pre></td></tr></table></figure><center>    <img src="jc2.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">基于ES6的继承</div></center><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ES6的class加extend是继承方式本质仍然是ES5的原型方式，只是看起来更加简洁方便，而且更贴切传统面向对象语言的特点。还有就是ES5中继承方式有一个点必须注意：子类的原型由于改成了父类的一个实例，那么子类的原型的construct也就自然随之指向了父类的构造函数，这是不符合规范的（这个时候对子类原型添加的方法会影响父类）。所以必须进行矫正，让子类原型的construct从新指向子类自己的构造函数：Son.prototype.constructor &#x3D; Son;在ES6这种语法糖的情况下就不需要考虑这么多细节了。这也是语法糖的一个特点：写法更加简单，但本质却没有改变。至于ES5中用到的call方法和ES6中用到的super方法要先理解new关键字执行背后的原理了！！</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>js </tag>
      
      <tag>原型</tag>
      
      <tag>class</tag>
      
      <tag>es5</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/02/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/02/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2023/02/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/cat.png" class="" title="图片引用方法以"><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-primary">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-warning">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><span class="label label-primary">text</span><span class="label label-default">text2</span><span class="label label-info">text3</span><span class="label label-success">text4</span><span class="label label-warning">text5</span><span class="label label-danger">text6</span><a class="btn" href="https://www.baidu.com"  title="百度" target="_blank">百度</a><!-- <a class="btn" href="https://www.baidu.com" title="title">text</a> -->]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/20/hello-world/"/>
    <url>/2023/02/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jsonp</title>
    <link href="/2022/06/13/jsonp/"/>
    <url>/2022/06/13/jsonp/</url>
    
    <content type="html"><![CDATA[<p>jsonp是一种传统的能够跨域请求服务端数据的一种前后端通信方式（其实现在的网页也还在使用这种技术）。</p><h3 id="Jsonp原理简介"><a href="#Jsonp原理简介" class="headerlink" title="Jsonp原理简介"></a>Jsonp原理简介</h3><pre><code class="hljs">1.利用的就是script标签src属性没有跨域限制来实现的（Ajax请求是受到浏览器跨域限制的，需要设置服务器设置响应头CORS来解决跨域，但script、img等标签的src属性天然就能发get请求，但这种请求并不是普通的ajax请求）</code></pre><p>　　　　（1） script的特性：会将引用的外部文件的文本内容当做js代码来进行解析</p><p>　　　　（2） 发送get请求将远程服务器的资源添（往往是一段JavaScript代码）加载到浏览器进行解析并执行</p><p>　　　　（3） json的格式：属性名必须有冒号，例如{“score”：99}</p><p>　　　　（4） jsonp&#x3D;&#x3D;json+padding</p><center>    <img src="jsonp.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">jsonp方式服务器返回其实就是一段js文本</div></center><pre><code class="hljs">2.执行的过程</code></pre><p>　　　　（1）前、端约定好一个解析函数，例如  function myJsonpHander(data){ console.log(data) }</p><p>　　　　（2）通过query的形式包装script的请求参数，并且声明执行函数如http://127.0.0.1:8088&#x2F;jsonp?cb&#x3D;myJsonpHander</p><p>　　　　（3）后端获取到前端声明的执行函数（myJsonpHander），把数据以json的格式拼接成函数调用的方式，最终把这个拼接好的字符串发送给前端</p><p>　　　　（4）前端在script标签返回资源的时候就回执行服务端返回那段js字符串代码，并以回调函数的方式拿到返回的数据了</p><center>    <img src="font.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">前端通过script标签发送可以跨域的get请求</div></center><center>    <img src="back.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">服务端获取到前端的参数，基于此参数拼接json数据形成一个函数调用格式的字符串发给前端</div></center><pre><code class="hljs">3.优缺点</code></pre><p>　　　　（1）缺点：只能进行get请求，优点：兼容性好，在一些老的浏览器中也可以运行</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>服务器代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<br><span class="hljs-keyword">const</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>);<span class="hljs-comment">//url模块专门用来解析request.url（处理请求路径）</span><br>http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) &#123;<br>  <span class="hljs-keyword">let</span> parsedUrl = url.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedUrl)<br>  <span class="hljs-keyword">const</span> &#123;search, query, pathname&#125; = parsedUrl<br>  <span class="hljs-keyword">if</span>(pathname === <span class="hljs-string">&quot;/favicon.ico&quot;</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;./favicon.ico&quot;</span>,<span class="hljs-function">(<span class="hljs-params">err, dataStr</span>)=&gt;</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr)<span class="hljs-comment">//buffer</span><br>      response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;image/x-icon&#x27;</span>&#125;);<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">end</span>(dataStr);<br>    &#125;)<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pathname === <span class="hljs-string">&quot;/jsonp&quot;</span>)&#123;<br>    <span class="hljs-keyword">if</span>(query.<span class="hljs-property">cb</span> === <span class="hljs-string">&quot;myJsonpHander&quot;</span>)&#123;<br>      <span class="hljs-keyword">const</span> obj = &#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tom&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>,<br>        <span class="hljs-attr">scores</span>:[<br>          &#123;<span class="hljs-attr">math</span>:<span class="hljs-number">100</span>, <span class="hljs-attr">english</span>:<span class="hljs-number">90</span>, <span class="hljs-attr">java</span>:<span class="hljs-number">80</span>, <span class="hljs-attr">time</span>:<span class="hljs-number">1</span>&#125;, <br>          &#123;<span class="hljs-attr">math</span>:<span class="hljs-number">89</span>, <span class="hljs-attr">english</span>:<span class="hljs-number">86</span>, <span class="hljs-attr">java</span>:<span class="hljs-number">80</span>, <span class="hljs-attr">time</span>:<span class="hljs-number">2</span>&#125;,<br>          &#123;<span class="hljs-attr">math</span>:<span class="hljs-number">96</span>, <span class="hljs-attr">english</span>:<span class="hljs-number">40</span>, <span class="hljs-attr">java</span>:<span class="hljs-number">90</span>, <span class="hljs-attr">time</span>:<span class="hljs-number">3</span>&#125;,]<br>      &#125;<br>      <span class="hljs-comment">// 构建返回前端的js代码（就是一段普通js字符串）</span><br>      <span class="hljs-keyword">const</span> cbStr =  <span class="hljs-string">`</span><br><span class="hljs-string">      try&#123;</span><br><span class="hljs-string">        myJsonpHander(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(obj)&#125;</span>);</span><br><span class="hljs-string">      &#125;catch(e)&#123;&#125;</span><br><span class="hljs-string">      `</span><br>      response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>      response.<span class="hljs-title function_">end</span>(cbStr);<br>    &#125;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;);<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>  &#125;<br><br>&#125;).<span class="hljs-title function_">listen</span>(<span class="hljs-number">8088</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running at http://127.0.0.1:8088/&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>前端代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myJsonpHander</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>  &#125;<br>&lt;script src=<span class="hljs-string">&quot;http://127.0.0.1:8088/jsonp?cb=myJsonpHander&quot;</span>&gt;&lt;/script&gt;<br>  &lt;script&gt;<br>    <span class="hljs-keyword">const</span> data = &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;tom&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">19</span>,<br>      <span class="hljs-string">&quot;scores&quot;</span>:<br>        [<br>          &#123;<span class="hljs-string">&quot;math&quot;</span>:<span class="hljs-number">100</span>,<span class="hljs-string">&quot;english&quot;</span>:<span class="hljs-number">90</span>,<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-number">80</span>,<span class="hljs-string">&quot;time&quot;</span>:<span class="hljs-number">1</span>&#125;,<br>          &#123;<span class="hljs-string">&quot;math&quot;</span>:<span class="hljs-number">89</span>,<span class="hljs-string">&quot;english&quot;</span>:<span class="hljs-number">86</span>,<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-number">80</span>,<span class="hljs-string">&quot;time&quot;</span>:<span class="hljs-number">2</span>&#125;,<br>          &#123;<span class="hljs-string">&quot;math&quot;</span>:<span class="hljs-number">96</span>,<span class="hljs-string">&quot;english&quot;</span>:<span class="hljs-number">40</span>,<span class="hljs-string">&quot;java&quot;</span>:<span class="hljs-number">90</span>,<span class="hljs-string">&quot;time&quot;</span>:<span class="hljs-number">3</span>&#125;<br>        ]<br>    &#125;<br>     <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-title function_">myJsonpHander</span>(data);<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注意：http请求有很多种，比如Windows自带的curl命令、linux自带的wget命令，以及各种语言自带的请求库（比如nodejs的http模块、java的HttpClient模块、python的requests模块等等各种计算机语言都提供了自己网络请求库）但这些http请求方式中，只有浏览器里面ajax请求和fetch请求才会受到同源策略的影响，导致浏览器认为是不安全的数据，从而把数据包给丢了（实际上服务器已经发送了数据，并且浏览器也收到了数据），显然只有浏览器的这种Ajax请求和fetch请求才有此问题，其他都不存在这个问题，浏览器的锅自然不能丢到服务器身上了，在前端开发中为了解决这个跨域问题，官方推荐的做法都是<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a>（Cross-Origin Resource Sharing跨域资源共享），在服务器上设置一系列的响应头来告诉浏览器这是安全的资源，让浏览器“放心”的接受这数据。（如果是客户端发送http请求自然不用服务器这样多此一举了），这种问题也只有在浏览器中才会出现，这种解决方案却需要服务端配合（当然前端自己也可以搭建代理服务器来解决跨域，但本质来讲还是在代理服务器上做了cors）；所以这种方案最终还是离不开服务器，有没有不需要修改服务器的方案呢？jsonp就具有天然支持跨域获取服务器资源的特点。jsonp方法也还是需要和服务器配合沟通协商好一个标识以及传输的数据格式，所以无论怎样，沟通配合还是少不了的。<br>jsonp由于只能发送get请求，而且较为繁琐，相对如今的请求库而言早已经失去了优势，但它其实仍然运行在现代web网页中，即使现在如此纷繁复杂的网页已经抛弃了很多古老的技术，但jsonp仍然可以见到其身影，比如经典的pv、uv统计库<a href="http://busuanzi.ibruce.info/">不蒜子</a>，简洁的几段代码就可以统计网站的访问量和访问人数，其背后就是通过构建一个jsonp请求去向服务器拉取数据，展示到网页。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js </tag>
      
      <tag>jsonp</tag>
      
      <tag>node服务器</tag>
      
      <tag>前端后端数据交换</tag>
      
      <tag>跨域</tag>
      
      <tag>http请求</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defineProperty</title>
    <link href="/2022/04/22/defineProperty/"/>
    <url>/2022/04/22/defineProperty/</url>
    
    <content type="html"><![CDATA[<p>Object.defineProperty() 方法可以直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><h3 id="value、writable、enumerable"><a href="#value、writable、enumerable" class="headerlink" title="value、writable、enumerable"></a>value、writable、enumerable</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// value</span><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;;<br><span class="hljs-keyword">var</span> new_obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj === new_obj)<span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>)<span class="hljs-comment">//张三</span><br><br><span class="hljs-comment">// writable</span><br><span class="hljs-keyword">var</span> obj2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>, <span class="hljs-attr">id</span>:<span class="hljs-number">1101</span>&#125;;<br><span class="hljs-keyword">var</span> new_obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj2, <span class="hljs-string">&quot;id&quot;</span>, &#123;<br>  <span class="hljs-attr">writable</span>:<span class="hljs-literal">false</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);<br>obj2.<span class="hljs-property">id</span> = <span class="hljs-number">100</span>;<span class="hljs-comment">//可以进行赋值，但不会生效</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);<span class="hljs-comment">//obj.id仍然为1101</span><br><br></code></pre></td></tr></table></figure><center>    <img src="writable.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">给对象某一个属性设置writable属性为false后，修改该属性不会生效（该属性无法被修改）</div></center><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p>默认情况下Object.defineProperty新添加的属性是不可修改的（不能用obj3.address&#x3D;”湖南”这种方式进行修改），且不能被for…in和Object.keys方法进行遍历到的。但通过属性赋值操作添加的普通属性是可以被枚举的例如var o &#x3D; {a:1};o.b&#x3D;2;那么对象o的b属性是可以被枚举出来的，但用Object.defineProperty添加的新属性默认是不能被枚举和修改的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">var</span> obj3 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">29</span>, <span class="hljs-attr">id</span>:<span class="hljs-number">1102</span>&#125;;<br><span class="hljs-keyword">var</span> new_obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj3, <span class="hljs-string">&quot;address&quot;</span>, &#123;<br>  <span class="hljs-attr">writable</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//该属性值默认就是fasle，所以不写也是一样的效果</span><br>  <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//该属性值默认就是fasle，所以不写也是一样的效果</span><br>  <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;上海&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj3);<br>obj3.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;北京&quot;</span>;<span class="hljs-comment">//可以进行赋值，但不会生效</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj3);<span class="hljs-comment">//obj.address仍然为上海</span><br><br></code></pre></td></tr></table></figure><center>    <img src="xinjiashuxing.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">用Object.defineProperty添加的新属性默认是不能被枚举和修改的</div></center><h3 id="setter、getter"><a href="#setter、getter" class="headerlink" title="setter、getter"></a>setter、getter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;;<br><span class="hljs-keyword">var</span> new_obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了get方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> obj[<span class="hljs-string">&#x27;name&#x27;</span>];<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用了set方法&quot;</span>);<br>    obj[<span class="hljs-string">&#x27;name&#x27;</span>] = value;<br>  &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj === new_obj)<span class="hljs-comment">//true</span><br><span class="hljs-comment">// 注意：调用set和get函数时一定要外面包一层函数，否则会一直递归执行（下面两行代码不能直接执行）</span><br>new_obj.<span class="hljs-property">name</span>;<br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es5</tag>
      
      <tag>自定义属性</tag>
      
      <tag>属性控制</tag>
      
      <tag>Object方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Antimalware Service Executable占用过高cpu问题</title>
    <link href="/2022/02/21/Executable%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98cpu%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/21/Executable%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98cpu%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<!-- <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"    src="circle.jpg" width="60"> --><p>最近由于硬盘坏了，自己买了个ssd重新安装了一个操作系统，安装好用着也没问题，但忽然发现鼠标光标一直在那里闪烁，但我并没有打开非常吃内存的软件。</p><center>    <img width="60" src="circle.jpg">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">闪烁的鼠标光标</div></center>这个时候我打开Windows任务管理器发现cpu使用率已经达到了90%，内存使用率达到了60%；正常情况下win10系统运行内存大约需要4个G，对于我这16G的内存而已，不可能打开了几个软件就占用了这么多资源。而一直在闪烁的光标显然在说明有很消耗cpu的进程在后台运行。<center>    <img width="600" src="cpu1.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">高负荷的cpu和内存资源</div></center>高负荷的cpu使用图上有一个占用45.5%的后台进程，显然鼠标一直闪烁的罪魁祸首就在于这个叫Antimalware Service Executable的进程！<br/><br/>反恶意软件服务（Antimalware Service Executable） 是一个 Windows 安全进程，它执行针对恶意软件的实时保护。本来是一个系统自带的软件保护程序，咋就成了严重影响计算机性能的“恶意程序”了呢？其背后原因就在于它扫描了自己的文件夹--C:\Program Files\Windows Defender，因此，只要阻止了Antimalware Service Executable 扫描其自己的文件夹就能减少其占用CPU的比例，从而大大的节约cpu资源以使计算机变得正常流畅。<br/><br/>以下是修改Antimalware Service Executable配置后的cpu及内存使用情况：<center>    <img width="600" src="cpu2.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">正常的cpu使用状态</div></center>经过查阅资料，总结了避免Antimalware Service Executable时刻扫描自己的文件夹的方法如下：<br/>第 1 步：按 WIN（Windows 键）+ R打开运行对话框。<br/>第 2 步：键入 “taskschd.msc”，然后单击“确定”，这将打开任务计划程序（Task Scheduler）。<center>    <img width="600" src="taskschd.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">打开任务计划程序</div></center>第 3 步：展开“任务计划程序选项卡”，“Microsoft”和“Windows”并找到 “Windows Defender”。<center>    <img width="600" src="defender.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Windows Defender</div></center>第 4 步：右键单击 “Windows Defender Scheduled Scan”并选择“属性”。<center>    <img width="600" src="select.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">Windows Defender Scheduled Scan</div></center>第 5 步：取消选中“以最高权限运行”<center>    <img width="600" src="cancel.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">取消选中“以最高权限运行”</div></center>第 6 步：转到“条件”选项卡并取消选中那里的所有内容。<center>    <img width="600" src="cancelall.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">修改触发器运行条件</div></center>第 7 步：重新启动计算机。这样，Antimalware Service Executable 就不会再占用太多 CPU 了。至此cpu使用率就恢复正常，鼠标光标不停闪烁的问题也随着自然消失了！！！<center>    <img width="600" src="cpu2.png" style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">正常的cpu使用状态</div></center>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpu飙升</tag>
      
      <tag>Antimalware </tag>
      
      <tag>Defender</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
